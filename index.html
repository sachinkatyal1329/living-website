<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game - This website is alive</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: #fff;
            padding: 2rem;
            overflow-x: hidden;
            position: relative;
        }

        #pong-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            opacity: 0.3;
            pointer-events: none;
        }

        /* === PROTECTED ZONE - DO NOT MODIFY === */
        #phone-display {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 9999;
            background: #111;
            color: #fff;
            padding: 1rem 2rem;
            border-radius: 8px;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            letter-spacing: 0.05em;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }

        #phone-display small {
            display: block;
            font-size: 0.75rem;
            font-weight: normal;
            opacity: 0.8;
            margin-top: 0.25rem;
        }

        #phone-display a {
            color: #fff;
            text-decoration: none;
        }
        /* === END PROTECTED ZONE === */

        /* === PROTECTED ZONE - DO NOT MODIFY === */
        main {
            max-width: 600px;
            text-align: center;
            padding-bottom: 120px;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 1rem;
        }

        p {
            font-size: 1.125rem;
            line-height: 1.6;
            color: #ddd;
        }
        /* === END PROTECTED ZONE === */

        main {
            position: relative;
            z-index: 10;
        }

        .chess-container {
            position: relative;
            z-index: 10;
            max-width: 600px;
            width: 100%;
            padding: 2rem;
            margin-top: 2rem;
            margin-bottom: 140px;
        }

        .game-info {
            text-align: center;
            margin-bottom: 2rem;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 1.5rem;
        }

        .game-status {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .turn-indicator {
            font-size: 1rem;
            opacity: 0.9;
        }

        #chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 0;
            aspect-ratio: 1;
            width: 100%;
            max-width: 560px;
            margin: 0 auto;
            border: 4px solid #2c3e50;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
        }

        .square {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s;
        }

        .square.light {
            background-color: #f0d9b5;
        }

        .square.dark {
            background-color: #b58863;
        }

        .square.selected {
            background-color: #7fa650 !important;
        }

        .square.valid-move {
            background-color: #aad662 !important;
        }

        .square.last-move {
            background-color: #cdd26a !important;
        }

        .square:hover {
            filter: brightness(0.9);
        }

        .controls {
            text-align: center;
            margin-top: 2rem;
        }

        .btn {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 0.75rem 2rem;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin: 0.5rem;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }

        @media (max-width: 768px) {
            body {
                padding: 1rem;
                padding-bottom: 180px;
            }

            .chess-container {
                padding: 1rem;
                margin-bottom: 160px;
            }

            .square {
                font-size: 2rem;
            }

            #chessboard {
                max-width: min(90vw, calc(100vh - 400px));
                width: 100%;
            }

            .game-info {
                padding: 1rem;
            }
        }

        @media (max-width: 768px) and (orientation: landscape) {
            body {
                padding-bottom: 140px;
            }

            .chess-container {
                margin-bottom: 120px;
            }

            #chessboard {
                max-width: min(50vh, 90vw);
            }
        }

        /* === PROTECTED ZONE - DO NOT MODIFY === */
        .site-nav {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            display: inline-flex;
            gap: 0.25rem;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(20px);
            border-radius: 100px;
            padding: 0.25rem;
            z-index: 9998;
        }

        .site-nav button {
            padding: 0.5rem 1.25rem;
            border: none;
            background: transparent;
            font-size: 0.875rem;
            font-weight: 500;
            color: rgba(255,255,255,0.6);
            cursor: pointer;
            border-radius: 100px;
            transition: all 0.2s;
        }

        .site-nav button:hover {
            color: #fff;
        }

        .site-nav button.active {
            background: rgba(255,255,255,0.15);
            color: #fff;
        }

        .view {
            display: none;
            width: 100%;
            flex-direction: column;
            align-items: center;
            padding-top: 60px;
        }

        .view.active {
            display: flex;
        }

        #history-view {
            max-width: 600px;
            width: 100%;
            padding: 20px 2rem 140px;
        }

        .history-list {
            list-style: none;
        }

        .history-item {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            padding: 1rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .history-item:last-child {
            border-bottom: none;
        }

        .history-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            color: rgba(255,255,255,0.5);
        }

        .history-content {
            flex: 1;
            min-width: 0;
        }

        .history-phone {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.5);
            margin-bottom: 0.25rem;
        }

        .history-prompt {
            font-size: 0.9375rem;
            color: rgba(255,255,255,0.9);
            line-height: 1.4;
        }

        .history-empty {
            text-align: center;
            color: rgba(255,255,255,0.5);
            padding: 3rem 0;
        }
        /* === END PROTECTED ZONE === */

        .hello-world {
            font-size: 3rem;
            font-weight: bold;
            text-align: center;
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .dog-circle-container {
            position: relative;
            width: 220px;
            height: 220px;
            margin: 2rem auto 1rem;
            z-index: 10;
        }

        .dog-circle-track {
            position: absolute;
            inset: 0;
            border-radius: 50%;
            border: 3px dashed rgba(255,255,255,0.3);
        }

        .dog-runner {
            position: absolute;
            top: 50%;
            left: 50%;
            font-size: 2rem;
            animation: dogRunCircle 2.5s linear infinite;
            transform-origin: 0 0;
            margin-top: -1rem;
            margin-left: -1rem;
        }

        @keyframes dogRunCircle {
            0%   { transform: rotate(0deg)   translateX(90px) rotate(0deg); }
            50%  { transform: rotate(180deg) translateX(90px) rotate(-180deg) scaleX(-1); }
            50.001% { transform: rotate(180deg) translateX(90px) rotate(-180deg) scaleX(1); }
            100% { transform: rotate(360deg) translateX(90px) rotate(-360deg); }
        }

        .dog-label {
            text-align: center;
            color: rgba(255,255,255,0.7);
            font-size: 0.9rem;
            margin-bottom: 1.5rem;
            z-index: 10;
            position: relative;
        }
    </style>
</head>
<body>
    <canvas id="pong-canvas"></canvas>

    <!-- === PROTECTED ZONE - DO NOT MODIFY === -->
    <nav class="site-nav">
        <button class="active" data-view="main-view">Home</button>
        <button data-view="history-view">History</button>
    </nav>
    <!-- === END PROTECTED ZONE === -->

    <!-- === PROTECTED ZONE - DO NOT MODIFY === -->
    <div id="main-view" class="view active">
    <!-- === END PROTECTED ZONE === -->

    <div class="hello-world">Hello Sachin</div>
    <div class="chess-container">
        <div class="game-info">
            <div class="game-status" id="game-status">Your turn - Play as Black</div>
            <div class="turn-indicator" id="turn-indicator">Click a piece to start</div>
        </div>
        <div id="chessboard"></div>
        <div class="controls">
            <button class="btn" onclick="resetGame()">New Game</button>
        </div>
    </div>

    <script>
        // Chess piece Unicode symbols
        const pieces = {
            'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
            'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
        };

        // Initial board setup (White pieces on bottom rows 6-7, Black pieces on top rows 0-1)
        let board = [
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r']
        ];

        let selectedSquare = null;
        let playerColor = 'black';
        let currentTurn = 'black';
        let lastMove = null;
        let gameOver = false;

        function createBoard() {
            const chessboard = document.getElementById('chessboard');
            chessboard.innerHTML = '';

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;

                    if (lastMove &&
                        ((lastMove.fromRow === row && lastMove.fromCol === col) ||
                         (lastMove.toRow === row && lastMove.toCol === col))) {
                        square.classList.add('last-move');
                    }

                    const piece = board[row][col];
                    if (piece) {
                        square.textContent = pieces[piece];
                    }

                    square.addEventListener('click', () => handleSquareClick(row, col));
                    chessboard.appendChild(square);
                }
            }
        }

        function handleSquareClick(row, col) {
            if (gameOver) return;
            if (currentTurn !== playerColor) return;

            const piece = board[row][col];

            if (selectedSquare) {
                const validMoves = getValidMoves(selectedSquare.row, selectedSquare.col);
                const isValidMove = validMoves.some(move => move.row === row && move.col === col);

                if (isValidMove) {
                    makeMove(selectedSquare.row, selectedSquare.col, row, col);
                    selectedSquare = null;
                    updateBoard();

                    if (!gameOver) {
                        currentTurn = 'white';
                        updateStatus();
                        setTimeout(makeComputerMove, 500);
                    }
                } else {
                    selectedSquare = null;
                    updateBoard();
                }
            } else {
                if (piece && isPlayerPiece(piece)) {
                    selectedSquare = { row, col };
                    updateBoard();
                }
            }
        }

        function isPlayerPiece(piece) {
            return playerColor === 'white' ? piece === piece.toUpperCase() : piece === piece.toLowerCase();
        }

        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol];

            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = null;

            lastMove = { fromRow, fromCol, toRow, toCol };

            // Check for checkmate/game over
            if (capturedPiece && capturedPiece.toLowerCase() === 'k') {
                gameOver = true;
                document.getElementById('game-status').textContent =
                    currentTurn === 'black' ? 'You Win!' : 'Computer Wins!';
            }
        }

        function getValidMoves(row, col) {
            const piece = board[row][col];
            if (!piece) return [];

            const moves = [];
            const isWhite = piece === piece.toUpperCase();

            switch (piece.toLowerCase()) {
                case 'p': // Pawn
                    const direction = isWhite ? -1 : 1;
                    const startRow = isWhite ? 1 : 6;

                    // Forward move
                    if (board[row + direction]?.[col] === null) {
                        moves.push({ row: row + direction, col });

                        // Double move from start
                        if (row === startRow && board[row + 2 * direction]?.[col] === null) {
                            moves.push({ row: row + 2 * direction, col });
                        }
                    }

                    // Captures
                    [-1, 1].forEach(dc => {
                        const targetPiece = board[row + direction]?.[col + dc];
                        if (targetPiece && (targetPiece === targetPiece.toUpperCase()) !== isWhite) {
                            moves.push({ row: row + direction, col: col + dc });
                        }
                    });
                    break;

                case 'n': // Knight
                    [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(([dr,dc]) => {
                        const newRow = row + dr, newCol = col + dc;
                        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            const targetPiece = board[newRow][newCol];
                            if (!targetPiece || (targetPiece === targetPiece.toUpperCase()) !== isWhite) {
                                moves.push({ row: newRow, col: newCol });
                            }
                        }
                    });
                    break;

                case 'b': // Bishop
                    addLineMoves(row, col, [[1,1],[1,-1],[-1,1],[-1,-1]], moves, isWhite);
                    break;

                case 'r': // Rook
                    addLineMoves(row, col, [[0,1],[0,-1],[1,0],[-1,0]], moves, isWhite);
                    break;

                case 'q': // Queen
                    addLineMoves(row, col, [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]], moves, isWhite);
                    break;

                case 'k': // King
                    [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]].forEach(([dr,dc]) => {
                        const newRow = row + dr, newCol = col + dc;
                        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            const targetPiece = board[newRow][newCol];
                            if (!targetPiece || (targetPiece === targetPiece.toUpperCase()) !== isWhite) {
                                moves.push({ row: newRow, col: newCol });
                            }
                        }
                    });
                    break;
            }

            return moves;
        }

        function addLineMoves(row, col, directions, moves, isWhite) {
            directions.forEach(([dr, dc]) => {
                let newRow = row + dr, newCol = col + dc;
                while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const targetPiece = board[newRow][newCol];
                    if (!targetPiece) {
                        moves.push({ row: newRow, col: newCol });
                    } else {
                        if ((targetPiece === targetPiece.toUpperCase()) !== isWhite) {
                            moves.push({ row: newRow, col: newCol });
                        }
                        break;
                    }
                    newRow += dr;
                    newCol += dc;
                }
            });
        }

        function makeComputerMove() {
            if (gameOver) return;

            // Find all white pieces and their valid moves
            const allMoves = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece === piece.toUpperCase()) {
                        const moves = getValidMoves(row, col);
                        moves.forEach(move => {
                            allMoves.push({ fromRow: row, fromCol: col, toRow: move.row, toCol: move.col });
                        });
                    }
                }
            }

            if (allMoves.length > 0) {
                // Simple AI: prioritize captures, otherwise random move
                const captureMoves = allMoves.filter(move => board[move.toRow][move.toCol] !== null);
                const move = captureMoves.length > 0
                    ? captureMoves[Math.floor(Math.random() * captureMoves.length)]
                    : allMoves[Math.floor(Math.random() * allMoves.length)];

                makeMove(move.fromRow, move.fromCol, move.toRow, move.toCol);
                currentTurn = 'black';
                updateBoard();
                updateStatus();
            }
        }

        function updateBoard() {
            createBoard();

            if (selectedSquare) {
                const square = document.querySelector(
                    `[data-row="${selectedSquare.row}"][data-col="${selectedSquare.col}"]`
                );
                square.classList.add('selected');

                const validMoves = getValidMoves(selectedSquare.row, selectedSquare.col);
                validMoves.forEach(move => {
                    const validSquare = document.querySelector(
                        `[data-row="${move.row}"][data-col="${move.col}"]`
                    );
                    validSquare.classList.add('valid-move');
                });
            }
        }

        function updateStatus() {
            if (gameOver) return;

            document.getElementById('game-status').textContent =
                currentTurn === 'black' ? 'Your turn - Play as Black' : 'Computer is thinking...';
            document.getElementById('turn-indicator').textContent =
                currentTurn === 'black' ? 'Click a piece to move' : 'Please wait...';
        }

        function resetGame() {
            board = [
                ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'],
                ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r']
            ];
            selectedSquare = null;
            currentTurn = 'black';
            lastMove = null;
            gameOver = false;
            updateBoard();
            updateStatus();
        }

        // Handle window resize and orientation changes
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                updateBoard();
            }, 100);
        });

        // Initialize game
        createBoard();
        updateStatus();
    </script>

    <script>
        // Pong Game - Background Animation
        const canvas = document.getElementById('pong-canvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Pong game state
        const pongState = {
            ballX: 0,
            ballY: 0,
            ballVelX: 5,
            ballVelY: 5,
            ballRadius: 8,
            paddle1Y: 0,
            paddle2Y: 0,
            paddleWidth: 15,
            paddleHeight: 100,
            paddleSpeed: 4,
            score1: 0,
            score2: 0
        };

        function resetBall() {
            pongState.ballX = canvas.width / 2;
            pongState.ballY = canvas.height / 2;
            pongState.ballVelX = (Math.random() > 0.5 ? 1 : -1) * (4 + Math.random() * 2);
            pongState.ballVelY = (Math.random() - 0.5) * 8;
        }

        function resetGame() {
            pongState.score1 = 0;
            pongState.score2 = 0;
            resetBall();
        }

        resetBall();
        pongState.paddle1Y = canvas.height / 2 - pongState.paddleHeight / 2;
        pongState.paddle2Y = canvas.height / 2 - pongState.paddleHeight / 2;

        function updatePong() {
            // Move ball
            pongState.ballX += pongState.ballVelX;
            pongState.ballY += pongState.ballVelY;

            // Ball collision with top/bottom
            if (pongState.ballY - pongState.ballRadius < 0 ||
                pongState.ballY + pongState.ballRadius > canvas.height) {
                pongState.ballVelY = -pongState.ballVelY;
            }

            // Ball collision with paddles
            // Left paddle
            if (pongState.ballX - pongState.ballRadius < pongState.paddleWidth) {
                if (pongState.ballY > pongState.paddle1Y &&
                    pongState.ballY < pongState.paddle1Y + pongState.paddleHeight) {
                    pongState.ballVelX = Math.abs(pongState.ballVelX);
                    const hitPos = (pongState.ballY - pongState.paddle1Y) / pongState.paddleHeight;
                    pongState.ballVelY = (hitPos - 0.5) * 10;
                }
            }

            // Right paddle
            if (pongState.ballX + pongState.ballRadius > canvas.width - pongState.paddleWidth) {
                if (pongState.ballY > pongState.paddle2Y &&
                    pongState.ballY < pongState.paddle2Y + pongState.paddleHeight) {
                    pongState.ballVelX = -Math.abs(pongState.ballVelX);
                    const hitPos = (pongState.ballY - pongState.paddle2Y) / pongState.paddleHeight;
                    pongState.ballVelY = (hitPos - 0.5) * 10;
                }
            }

            // Score points
            if (pongState.ballX < 0) {
                pongState.score2++;
                resetBall();
                // Auto-restart after 1 second
                setTimeout(() => {
                    if (pongState.score2 >= 10) resetGame();
                }, 1000);
            }
            if (pongState.ballX > canvas.width) {
                pongState.score1++;
                resetBall();
                // Auto-restart after 1 second
                setTimeout(() => {
                    if (pongState.score1 >= 10) resetGame();
                }, 1000);
            }

            // AI for paddles (simple follow the ball)
            // Left paddle
            if (pongState.paddle1Y + pongState.paddleHeight / 2 < pongState.ballY - 35) {
                pongState.paddle1Y += pongState.paddleSpeed;
            } else if (pongState.paddle1Y + pongState.paddleHeight / 2 > pongState.ballY + 35) {
                pongState.paddle1Y -= pongState.paddleSpeed;
            }

            // Right paddle
            if (pongState.paddle2Y + pongState.paddleHeight / 2 < pongState.ballY - 35) {
                pongState.paddle2Y += pongState.paddleSpeed;
            } else if (pongState.paddle2Y + pongState.paddleHeight / 2 > pongState.ballY + 35) {
                pongState.paddle2Y -= pongState.paddleSpeed;
            }

            // Keep paddles in bounds
            pongState.paddle1Y = Math.max(0, Math.min(canvas.height - pongState.paddleHeight, pongState.paddle1Y));
            pongState.paddle2Y = Math.max(0, Math.min(canvas.height - pongState.paddleHeight, pongState.paddle2Y));
        }

        function drawPong() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Set color
            ctx.fillStyle = 'white';

            // Draw center line
            ctx.setLineDash([10, 15]);
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw paddles
            ctx.fillRect(0, pongState.paddle1Y, pongState.paddleWidth, pongState.paddleHeight);
            ctx.fillRect(canvas.width - pongState.paddleWidth, pongState.paddle2Y,
                        pongState.paddleWidth, pongState.paddleHeight);

            // Draw ball
            ctx.beginPath();
            ctx.arc(pongState.ballX, pongState.ballY, pongState.ballRadius, 0, Math.PI * 2);
            ctx.fill();

            // Draw scores
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(pongState.score1, canvas.width / 4, 60);
            ctx.fillText(pongState.score2, (canvas.width * 3) / 4, 60);
        }

        function pongGameLoop() {
            updatePong();
            drawPong();
            requestAnimationFrame(pongGameLoop);
        }

        pongGameLoop();
    </script>

    <div class="dog-circle-container">
        <div class="dog-circle-track"></div>
        <div class="dog-runner">üêï</div>
    </div>
    <div class="dog-label">zoom zoom</div>

    <!-- === PROTECTED ZONE - DO NOT MODIFY THIS ELEMENT === -->
    <main id="main-text">
        <h1>This website is alive.</h1>
        <p>It changes based on what people text it. Send a message describing how you'd like to change this site, and watch it evolve.</p>
    </main>
    <!-- === END PROTECTED ZONE === -->

    <!-- === PROTECTED ZONE - DO NOT MODIFY === -->
    </div>
    <!-- === END PROTECTED ZONE === -->

    <!-- === PROTECTED ZONE - DO NOT MODIFY STRUCTURE === -->
    <div id="history-view" class="view">
        <ul class="history-list" id="history-list">
            <!-- HISTORY_ENTRIES -->
            <li class="history-item">
    <div class="history-avatar">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/>
        </svg>
    </div>
    <div class="history-content">
        <div class="history-phone">***-***-8993</div>
        <div class="history-prompt">Sorry I meant not taking a poop I meant a dog running around in a circle</div>
    </div>
</li>
            <li class="history-item">
    <div class="history-avatar">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/>
        </svg>
    </div>
    <div class="history-content">
        <div class="history-phone">***-***-4099</div>
        <div class="history-prompt">Add a live game of pong to the background so it is always playing and restarting the game automatically and you can see this behind the game of chess</div>
    </div>
</li>
            <li class="history-item">
    <div class="history-avatar">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/>
        </svg>
    </div>
    <div class="history-content">
        <div class="history-phone">***-***-4099</div>
        <div class="history-prompt">Fix this game of chess, there are a few issues: the top row is white when it should be black, on mobile the dimensions are not great so sometimes the bottom row gets cut off and you can&#39;t see it and if I rotate my phone then rotate it back I only see a 4x4 grid instead of the whole board. Make sure to audit the board, pieces, and game logic and make sure everything is displayed well so it renders well on both desktop and mobile. Make no mistakes</div>
    </div>
</li>
            <li class="history-item">
    <div class="history-avatar">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/>
        </svg>
    </div>
    <div class="history-content">
        <div class="history-phone">***-***-2346</div>
        <div class="history-prompt">Change the top text from hello world to hello Sachin</div>
    </div>
</li>
        </ul>
    </div>
    <!-- === END PROTECTED ZONE === -->

    <!-- === PROTECTED ZONE - DO NOT MODIFY THIS ELEMENT === -->
    <div id="phone-display">
        (877) 665-5073
        <small>text to edit this website</small>
    </div>
    <!-- === END PROTECTED ZONE === -->

    <!-- === PROTECTED ZONE - DO NOT MODIFY === -->
    <script>
        // Navigation
        document.querySelectorAll('.site-nav button').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.site-nav button').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById(btn.dataset.view).classList.add('active');
            });
        });
    </script>
    <!-- === END PROTECTED ZONE === -->
</body>
</html>
